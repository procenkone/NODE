експорт - module.exports = {test}
імпорт - const {greeting} = require('./helper')
абсолютний шлях до файлу - __filename
абсолютний шлях до папки - __dirname
шлях з якого викликається нода -  process.cwd()
глобальна змінна - global.name (не використовувати! видима тільки в своєму модулі)

* вбудований модуль для роботи зі шляхами *
імпортнути - зареквайрети модуль - const path = require('path')

розділяє слешом шлях - const joinTest = path.join(__dirname,'test', 'test2', 'test3', 'test.txt')

приводить у нормальний вигляд шлях - path.normalize('test///test1//test2/////test\text.txt')

повертає абсолютний шлях і розстравляє слеші - path.resolve('test///test1//test2/text.txt')

* вбудований модуль для роботи з параметрами операційної системи компа *
імпортнути - зареквайрети модуль - const os = require('os')

добратись до ядер компа щоб розподілити навантаження на сервер - console.log(os.cpus())

визначити архітектуру операційної системи - console.log(os.arch()) 64,32,86..

* вбудований модуль для роботи з фвйловою системою *
const fs = require('fs')

створити файл - fs.writeFile(path.join(__dirname, "папка", 'text.txt'),'some data ',(err)=>{
                    if(err){
                        console.log(err)
                        throw err - зупиняє продовження коду
                    }
                })

читати файл - fs.readFile(path.join(__dirname, 'file', 'text.txt'),'utf8',(err,data)=>{
                 if(err){
                     console.log(err)
                     throw err
                 }
                  console.log(data)
              })

дописати файл - fs.appendFile(path.join(__dirname,'file', 'text.txt'),'\nNew Dadta',(err)=>{
                    if(err){
                        console.log(err)
                        throw err
                    }
                })

перезаписати файл - fs.appendFile(path.join(__dirname,'file','text.txt'),'\ndata',{flag: 'w'},(err)=>{
                        if(err){
                            console.log(err)
                            throw err
                        }
                    })

очистити файл - fs.truncate(path.join(__dirname,'file','text.txt'), (err)=>{
                      if(err){
                          console.log(err)
                          throw err
                      }
                 })

видалити файл - fs.unlink(path.join(__dirname,'file','text.txt'), err=>{
                    if(err){
                        console.log(err)
                    }
                })

створити папку - fs.mkdir(path.join(__dirname, 'public', 'text.txt'), (err)=>{
                     if(err){
                         console.log(err)
                         throw err
                     }
                 })
створити дерево папок - fs.mkdir(path.join(__dirname, 'public', 'text', 'test2', 'test3'),{recursive:true} ,(err)=>{
                            if(err){
                                console.log(err)
                                throw err
                            }
                        })

видалити папку - fs.rmdir(path.join(__dirname,'public/text/test2/test3'),(err)=>{
                     if(err){
                         console.log(err)
                         throw err
                     }
                 })

перевірити що є в папці - fs.readdir(path.join(__dirname,'public'), (err,data)=>{
                              if(err){
                                  console.log(err)
                                  throw err
                              }
                              console.log(data)
                          })

переіменувати файл - fs.rename(path.join(__dirname,'public','tets2.txt'),path.join(__dirname,'public','test33.txt'), (err)=>{
                         if(err){
                             console.log(err)
                             throw err
                         }
                     })

перемістити файл в інше місце - fs.rename(path.join(__dirname,'public','test33.txt'),path.join(__dirname,'test33.txt'),(err)=>{
                                    if(err){
                                        console.log(err)
                                        throw err
                                    }
                                })


  **** module.exports, require('./helper'),
   __filename, __dirname,
    process.cwd(), path.join,
   path.normalize, path.resolve,
    os.cpus(), os.arch(),
    fs.writeFile, fs.readFile, fs.appendFile
   fs.truncate, fs.unlink, fs.mkdir, fs.rmdir, fs.readdir,fs.rename *****

   ///////////////////////////////////events node js///////////////////////////////
   модуль events
імпорт івенту - const {EventEmitter} = require('events')

присвоїти клас для події - const ee = new EventEmitter()

викликаєм наш клас і підставляєм метод "on" - ee.on('log',()=>{
                                                  console.log('log is working')
                                              })

щоб викликати результат підставляєм клас emit (з емітуй поведінку) і передаєм назву нашої події - ee.emit('log')

цей івент "on" буде спрацьовувати стільки разів скільки буде його виклик - ee.emit('log')

для разового відпрацювання коду можна заюзати івент "once", наприклад для створення папок і файлів, щоб кожен раз не перестворювались
щоб івент спрацював тільки один раз то використовуємо не "on" а "once" навіть якщо є багато викликів -  ee.once('testOnce',()=>{
                                                                                                            console.log('log test once')
                                                                                                       })

  ////////////// stream /////////////////////////////
  для читання або запису великих файлів по кусочкам, не нагружаючи сервер

створити сртім для читання - const readStream = fs.createReadStream(path.join(__dirname,'text.txt'))
використати стрім для читання - readStream.on('data',(chunk)=>{
                                    console.log(chunk)
                                })

створити стрім для запису - const writeStream = fs.createWriteStream(path.join(__dirname, 'fileTest.txt'))
використати стрім для запису - writeStream.write('some data write',(err)=>{
                                   if(err){
                                       console.log(err)
                                       return
                                   }
                               })
після виконання writeStream.write обовязково зупинити процес - writeStream.end()
ці методи можна поєднати з разовим використанням - івент "once"

прочитати і записати  великий файл - const readStream = fs.createReadStream(path.join(__dirname,'text.txt'))
                                     const writeStream = fs.createWriteStream(path.join(__dirname, 'fileTest.txt'))

                                     readStream.on('data',(chunk)=>{
                                         writeStream.write(chunk,(err)=>{
                                             if(err){
                                                 console.log(err)
                                                 return
                                             }
                                         })
                                         writeStream.end()
                                     })
це все то саме можна зробити одним методом "pipe" - readStream.pipe(writeStream)
ще стріми бувають: Readable — чтение
                   Writable — запись
                   Duplex — чтение и запись
                   Transform — вид Duplex потока, который может изменять данные(заархівувати)


 /////////////////////////////////////////////// express ////////////////
 1. підтягнути пакет з npm - npm i express
 2. зареквайрити експрес - const express = require('express')
 3. зробити обєкт з експресу - const app = express()
 4. створити сервер і вказати порт - app.listen(3001,()=>{
                                         console.log('server has started on port 3001')
                                     })
 5.створюєм гет метод в якому вказуєм шлях і колбек в якому:
 -req - те що прилітає з фронту
 -res - те що обробляєм на бекенді і відмальовуємо на фронті
 -res.send("...") - метод для відправки даних на фронт
 -res.json(users) - метод для відправки json формату на фронт

////////////////////////////////////////////// template ///////////////////
1. підтягнути з npm бібліотеку темплейту - npm i express-handlebars
2. зареквайрети - const express = require('express')
3. витягнути обєкт для подальшої роботи - const hbs = require('express-handlebars')
4. створюємо папку для зберігання наших темплейтів назва - static
5. реєструєм шлях до наших темплейтів - app.use(express.static(path.join(__dirname,'static')))
6. кажем ноді щоб встановила собі як двигун темплейтів саме hbs - app.set('view engine','.hbs')
7. з hbs потрібно деструктуризовати двигун - const {engine} = require('express-handlebars')
8. кажем ноді що коли вона бачить файл з розширенням .hbs то запусти двигун engine
 з параметром {defaultLayout:false} це означає що ми не використовуєм деревовидну структуру папок
  - app.engine('.hbs',engine({defaultLayout:false}))
9. кажем ноді що наші вюшки будуть записуватись по шляху - app.set('views',path.join(__dirname,'static'))
10. в папці static створюємо файл з розширенням login.hbs
-там відмальовуєм html структуру
-створюєм формочку, в атрибуті action='/login' прописуєм шлях при якому вона відпрацює
-підставляєм метод method='post'
-і потрібні інпути
11. пишем метод для відмальовки нашої вюшки:
-звертаємось до app
-підставляєм метод гет
-вказуємо шлях при якому відпрацює метод
-колбек стандартний ревест, респонс
-респонс.рендер вказуємо назву вюшки без розширення
app.get('/login',((req, res) => {
    res.render('login')
}))
-перезапускаєм ноду

12.тепер відловим данні із фронта з форми:
-напишем метод пост
-звертаємось до app
-підставляємо метод post
-вказуємо шлях на який він має відпрацювати
-стандартний колбек з реквест і респонс
-логієм реквест.боді
-приходить андефайнед тому вказуєм зверху формати які мають прилітати
-app.use(express.json()) - щоб нода могла приймати розширення json
-app.use(express.urlencoded({extended:true})) - щоб нода могла прийняти дані обєктом
данні отримані в req.body як обєкт
-запушим їх в наш масив юзерс

13. відмалюємо наших юзерів на окремій вюшці за посиланням '/users'
-створив файл з розширенням .hbs і відмалювати html структуру
-створити метод гет з шляхом на нашу вюшку - '/users'
-стандартний колбек
-рендерим респонс з назвою вюшки для відмальовки в другим параметром передаєм обєкт в якому наші юзери
-в нашій вюшці проітеруєм переданий масив таким чином:
<div>
    {{#each users}}
        <div>{{this.login}}</div>
        <div>{{this.password}}</div>
    {{/each}}
</div>

14. перенаправим клієнта на іншу сторінку після вводу данних в формі
-після того як ми отримали данні з форми:
-пушим їх в масив
-методом res.redirect('/users') - перенаправляєм користувача на іншу вюшку

15. якщо є задача відмалювати не всіх юзерів а одного:
-робим новий маршрут гет з шляхом '/users/:usersId'
-колбек
-в реквесті відловлюєм (req.params)
-деструктуризуєм req.params - const {usersId} = req.params
-передаєм в респонс для відмальовки одного юзера поки в
 форматі json динамічний індекс того юзера - res.json(users[usersId])

 16. для перевірки чи існує такий юзер в тому ж методі пост:
 -використовуєм метод req.query
 -перевірка чи є юзер з таким емейлом метод users.some(user=>user.email===req.body.email) і запишем результат відпрацювання в змінну
 -далі іфом перевірим тру чи фолс і якщо тру то перекинем на сторінку помилки
 -якщо фолс то запушим юзера в загальний масив
 -переведем на сторінку юзерів де відмалюється вес масив

 17. для фільтрації по квері параметрам:

 -в методі де відмальовуєм всіх юзерів деструктуризуєм з реквесту квері - {query}
 -перевірим чи є у наших квері довжина - if (Object.keys(query).length)
 -якщо нема то зупиним код ретурном
 -якщо є то зробим копію нашого основного масиву юзерів - let user = [...users]
 -далі іфом перевірим чи потрібний квері параметр існує
 -якщо існує то відфільтруєм у цей ж масив наш збіг -  user = user.filter(user => user.city === query.city)
 -так само фільтруєм інші квері параметри
 -при закінченні перевірок рендерим сторінку з юзерами передавши наш відфільтрований масив
 res.render('users', {users: user})
 -зупиняєм код.

 18. видаляємо юзера:
 -створили ендпоінт на виданення app.get('/delete/:idDelete', ({params}, res) => {
 -парамсами витягнули айдішку юзера якого треба видалити
 -фіндіндексом отримали індекс того обєкта з такою айдішкою -  const index = users.findIndex(item => item.id === +params.idDelete)
 - сплайсом видалили з загального масиву - users.splice(index, 1)
 - редіректнулись куди треба - res.redirect('/users');

 19. перехід на не існуючий шлях:
 - в самому кінці наших методів з шляхами викликаєм метод app.use але
 шлях зовсім не передаєм.
 -стандартний колбек
 -в респонсі рендерим хбс вюшку notFound з необхідним контекстом
 -метод app.use не дивиться на шлях а відпрацює зразу тому його ставим в сам низ

 //////////////////// routes //////////////

 1. створюємо папку routes
 2. створюємо файл userRouter
 3. в userRouter деструктуризуєм Router  з експресу - const {Router} = require('express')
 4. робим константу userRouter якій присвоюєм Router() виконаний - const userRouter = Router()
 5. звертаючись до  userRouter. бачимо всі методи get, post, delete
 6.створюєм папку типу емітуєм базу данних - db
 7. створюєм файл users.js і переносим туди масив юзерів і експоруємо його - module.exports = users;
 8. в файлі userRouter реквайремо цей масив з юзерами - const usersFromDb = require('../db/users')
 9. напишем роут - звертаємось до нашої константи userRouter через крапку дістаєм
 метод гет і в першому параметрв просто ставим слеш a другим параметром переносим колбек з логікою із апки
   - і експортуємо наш - module.exports = userRouter;
10. в папці routes створим файл apiRoutes
-в цьому файлі деструктуризуєм  Router так само як робити в файлі userRouters - const {Router} = require('express')
-реквайрим з файлу юзерРоутер корстанту юзерРоутер - const userRouter = require('./userRouter')

-нижче робимо константу routers - const routes = Router()
- з того routers через крапку дістаєм use() і першим переметром вкозуємо шлях '/users', а другим параметром
підставляємо userRouter який зареквайрили з файлу userRouter
-експортуємо головний роут - module.exports = routes;
-реквайрим в апку той головний роут - const apiRoutes = require('./routes/apiRoutes')
-в апці потрібно його активувати - app.use(apiRoutes)

11.перенесем з апки тепер роут з юзерс айдішкою:
-в юзерРоутерс створюєм новий метод гет і переносим туди шлях той самий але
вже без '/users' а тільки '/:id' і переносим всю логіку

12.так само робим з іншими роутами.

//////////////////////////////// controlers /////////////
1.створимо папку контролерс
2. в цій папці створим файл юзерсКонтролерс
3.створюємо класс UserControllers - class UserControllers{}
4.створюємо метод і називаєм відповідно до логіки що він робить- renderUsers(){

                                                    }
5.переносим з роуту всю логіку в метод -    renderUsers(req, res) {
                                                if (Object.keys(query).length) {//перевіряємо чи є наші квері
                                                    let user = [...users];//копія основного масиву юзерів для фільтрації
                                                    if (query.city) {
                                                        user = user.filter(user => user.city === query.city);//фільтруєм по місту
                                                    }
                                                    if (query.age) {
                                                        user = user.filter(user => user.age === query.age);//фільтруєм по віку
                                                    }
                                                    res.render('users', {users: user});//відмальовуємо відфільтроване
                                                    return
                                                }
                                                res.render('users', {users});//передаєм весь масив на сторінку для відмальрвки
                                            }
                                        }
6. не забуваєм в методі вказати аргументи методу renderUsers(req, res)
7. експортуємо цей екземпляр классу, саме класу а не методу - module.exports = new UserControllers()
 8. ідем в наш роут і реквайрем екземпляр класу - const UserControllers = require('../controllers/userControllers')
 9. видаляєм там логіку і залишаєм тільки шлях,а другим аргументом передаєм щойно зареквайрений екземпляр класу і через крапку
 підставляєм метод який відповідає за цю логіку, але як тіло а не як виклик. - userRouter.get('/',UserControllers.renderUsers);
 10. так само розгрузим логіку іншого роута


 ///////////////////////////middleware//////////////
 1.створюєм папку middleware
 2.стваорюєм файл isUserValid
 3. пишем функцію з такою ж назвою як файл,
 яка приймає три аргументи - req, res, next
 4.будуєм конструкцію try catch
 5.в try пишем всю логіку:
  -з реквеста у якому є баді деструктуризуєм - login і password
 це наші поля з форми логінації, які ми будем валідувати - const {login,password} = req.body
 -іфом перевіряєм чи  !логін і !пароль - if(!login || !password){
-і якщо не логін і не пасворд то зроу нев Еррор('login or password is not provided')
- другим іфом перевіряєм чи довжина пасворда більше 6 - якщо ні то пишем новий клас ерори
-остання дія в траї - next()
-в кетчі логаєм ерору.message - це той текс який ми ввели в клас еррори,  і відмальовуєм в респонс статус 400 і в сенд кладем еррору.message - catch (err) {res.status(400).send(err.message)}
- експортуємо нашу функцію - module.exports = isUserValid                                                                                           console.log(err.message)
- переходим в наш роут з логіном
-ревайримо функцію валідації - const isUserValid = require('../middleware/isUserValid')
-вставляємо її як тіло функції між шляхом і контроллером в той роут який треба валідувати
в нашому випадку це роут з методом пост, щоб при відправці перевірялт чи все добре
-мідлварів можна вставляти через кому стільки скільки треба













експорт - module.exports = {test}
імпорт - const {greeting} = require('./helper')
абсолютний шлях до файлу - __filename
абсолютний шлях до папки - __dirname
шлях з якого викликається нода -  process.cwd()
глобальна змінна - global.name (не використовувати! видима тільки в своєму модулі)

* вбудований модуль для роботи зі шляхами *
імпортнути - зареквайрети модуль - const path = require('path')

розділяє слешом шлях - const joinTest = path.join(__dirname,'test', 'test2', 'test3', 'test.txt')

приводить у нормальний вигляд шлях - path.normalize('test///test1//test2/////test\text.txt')

повертає абсолютний шлях і розстравляє слеші - path.resolve('test///test1//test2/text.txt')

* вбудований модуль для роботи з параметрами операційної системи компа *
імпортнути - зареквайрети модуль - const os = require('os')

добратись до ядер компа щоб розподілити навантаження на сервер - console.log(os.cpus())

визначити архітектуру операційної системи - console.log(os.arch()) 64,32,86..

* вбудований модуль для роботи з фвйловою системою *
const fs = require('fs')

створити файл - fs.writeFile(path.join(__dirname, "папка", 'text.txt'),'some data ',(err)=>{
                    if(err){
                        console.log(err)
                        throw err - зупиняє продовження коду
                    }
                })

читати файл - fs.readFile(path.join(__dirname, 'file', 'text.txt'),'utf8',(err,data)=>{
                 if(err){
                     console.log(err)
                     throw err
                 }
                  console.log(data)
              })

дописати файл - fs.appendFile(path.join(__dirname,'file', 'text.txt'),'\nNew Dadta',(err)=>{
                    if(err){
                        console.log(err)
                        throw err
                    }
                })

перезаписати файл - fs.appendFile(path.join(__dirname,'file','text.txt'),'\ndata',{flag: 'w'},(err)=>{
                        if(err){
                            console.log(err)
                            throw err
                        }
                    })

очистити файл - fs.truncate(path.join(__dirname,'file','text.txt'), (err)=>{
                      if(err){
                          console.log(err)
                          throw err
                      }
                 })

видалити файл - fs.unlink(path.join(__dirname,'file','text.txt'), err=>{
                    if(err){
                        console.log(err)
                    }
                })

створити папку - fs.mkdir(path.join(__dirname, 'public', 'text.txt'), (err)=>{
                     if(err){
                         console.log(err)
                         throw err
                     }
                 })
створити дерево папок - fs.mkdir(path.join(__dirname, 'public', 'text', 'test2', 'test3'),{recursive:true} ,(err)=>{
                            if(err){
                                console.log(err)
                                throw err
                            }
                        })

видалити папку - fs.rmdir(path.join(__dirname,'public/text/test2/test3'),(err)=>{
                     if(err){
                         console.log(err)
                         throw err
                     }
                 })

перевірити що є в папці - fs.readdir(path.join(__dirname,'public'), (err,data)=>{
                              if(err){
                                  console.log(err)
                                  throw err
                              }
                              console.log(data)
                          })

переіменувати файл - fs.rename(path.join(__dirname,'public','tets2.txt'),path.join(__dirname,'public','test33.txt'), (err)=>{
                         if(err){
                             console.log(err)
                             throw err
                         }
                     })

перемістити файл в інше місце - fs.rename(path.join(__dirname,'public','test33.txt'),path.join(__dirname,'test33.txt'),(err)=>{
                                    if(err){
                                        console.log(err)
                                        throw err
                                    }
                                })


  **** module.exports, require('./helper'),
   __filename, __dirname,
    process.cwd(), path.join,
   path.normalize, path.resolve,
    os.cpus(), os.arch(),
    fs.writeFile, fs.readFile, fs.appendFile
   fs.truncate, fs.unlink, fs.mkdir, fs.rmdir, fs.readdir,fs.rename *****

   ///////////////////////////////////events node js///////////////////////////////
   модуль events
імпорт івенту - const {EventEmitter} = require('events')

присвоїти клас для події - const ee = new EventEmitter()

викликаєм наш клас і підставляєм метод "on" - ee.on('log',()=>{
                                                  console.log('log is working')
                                              })

щоб викликати результат підставляєм клас emit (з емітуй поведінку) і передаєм назву нашої події - ee.emit('log')

цей івент "on" буде спрацьовувати стільки разів скільки буде його виклик - ee.emit('log')

для разового відпрацювання коду можна заюзати івент "once", наприклад для створення папок і файлів, щоб кожен раз не перестворювались
щоб івент спрацював тільки один раз то використовуємо не "on" а "once" навіть якщо є багато викликів -  ee.once('testOnce',()=>{
                                                                                                            console.log('log test once')
                                                                                                       })

  ////////////// stream /////////////////////////////
  для читання або запису великих файлів по кусочкам, не нагружаючи сервер

створити сртім для читання - const readStream = fs.createReadStream(path.join(__dirname,'text.txt'))
використати стрім для читання - readStream.on('data',(chunk)=>{
                                    console.log(chunk)
                                })

створити стрім для запису - const writeStream = fs.createWriteStream(path.join(__dirname, 'fileTest.txt'))
використати стрім для запису - writeStream.write('some data write',(err)=>{
                                   if(err){
                                       console.log(err)
                                       return
                                   }
                               })
після виконання writeStream.write обовязково зупинити процес - writeStream.end()
ці методи можна поєднати з разовим використанням - івент "once"

прочитати і записати  великий файл - const readStream = fs.createReadStream(path.join(__dirname,'text.txt'))
                                     const writeStream = fs.createWriteStream(path.join(__dirname, 'fileTest.txt'))

                                     readStream.on('data',(chunk)=>{
                                         writeStream.write(chunk,(err)=>{
                                             if(err){
                                                 console.log(err)
                                                 return
                                             }
                                         })
                                         writeStream.end()
                                     })
це все то саме можна зробити одним методом "pipe" - readStream.pipe(writeStream)
ще стріми бувають: Readable — чтение
                   Writable — запись
                   Duplex — чтение и запись
                   Transform — вид Duplex потока, который может изменять данные(заархівувати)


 /////////////////////////////////////////////// express ////////////////
 1. підтягнути пакет з npm - npm i express
 2. зареквайрити експрес - const express = require('express')
 3. зробити обєкт з експресу - const app = express()
 4. створити сервер і вказати порт - app.listen(3001,()=>{
                                         console.log('server has started on port 3001')
                                     })
 5.створюєм гет метод в якому вказуєм шлях і колбек в якому:
 -req - те що прилітає з фронту
 -res - те що обробляєм на бекенді і відмальовуємо на фронті
 -res.send("...") - метод для відправки даних на фронт
 -res.json(users) - метод для відправки json формату на фронт

////////////////////////////////////////////// template ///////////////////
1. підтягнути з npm бібліотеку темплейту - npm i express-handlebars
2. зареквайрети - const express = require('express')
3. витягнути обєкт для подальшої роботи - const hbs = require('express-handlebars')
4. створюємо папку для зберігання наших темплейтів назва - static
5. реєструєм шлях до наших темплейтів - app.use(express.static(path.join(__dirname,'static')))
6. кажем ноді щоб встановила собі як двигун темплейтів саме hbs - app.set('view engine','.hbs')
7. з hbs потрібно деструктуризовати двигун - const {engine} = require('express-handlebars')
8. кажем ноді що коли вона бачить файл з розширенням .hbs то запусти двигун engine
 з параметром {defaultLayout:false} це означає що ми не використовуєм деревовидну структуру папок
  - app.engine('.hbs',engine({defaultLayout:false}))
9. кажем ноді що наші вюшки будуть записуватись по шляху - app.set('views',path.join(__dirname,'static'))
10. в папці static створюємо файл з розширенням login.hbs
-там відмальовуєм html структуру
-створюєм формочку, в атрибуті action='/login' прописуєм шлях при якому вона відпрацює
-підставляєм метод method='post'
-і потрібні інпути
11. пишем метод для відмальовки нашої вюшки:
-звертаємось до app
-підставляєм метод гет
-вказуємо шлях при якому відпрацює метод
-колбек стандартний ревест, респонс
-респонс.рендер вказуємо назву вюшки без розширення
app.get('/login',((req, res) => {
    res.render('login')
}))
-перезапускаєм ноду

12.тепер відловим данні із фронта з форми:
-напишем метод пост
-звертаємось до app
-підставляємо метод post
-вказуємо шлях на який він має відпрацювати
-стандартний колбек з реквест і респонс
-логієм реквест.боді
-приходить андефайнед тому вказуєм зверху формати які мають прилітати
-app.use(express.json()) - щоб нода могла приймати розширення json
-app.use(express.urlencoded({extended:true})) - щоб нода могла прийняти дані обєктом
данні отримані в req.body як обєкт
-запушим їх в наш масив юзерс

13. відмалюємо наших юзерів на окремій вюшці за посиланням '/users'
-створив файл з розширенням .hbs і відмалювати html структуру
-створити метод гет з шляхом на нашу вюшку - '/users'
-стандартний колбек
-рендерим респонс з назвою вюшки для відмальовки в другим параметром передаєм обєкт в якому наші юзери
-в нашій вюшці проітеруєм переданий масив таким чином:
<div>
    {{#each users}}
        <div>{{this.login}}</div>
        <div>{{this.password}}</div>
    {{/each}}
</div>

14. перенаправим клієнта на іншу сторінку після вводу данних в формі
-після того як ми отримали данні з форми:
-пушим їх в масив
-методом res.redirect('/users') - перенаправляєм користувача на іншу вюшку

15. якщо є задача відмалювати не всіх юзерів а одного:
-робим новий маршрут гет з шляхом '/users/:usersId'
-колбек
-в реквесті відловлюєм (req.params)
-деструктуризуєм req.params - const {usersId} = req.params
-передаєм в респонс для відмальовки одного юзера поки в
 форматі json динамічний індекс того юзера - res.json(users[usersId])

 16. для перевірки чи існує такий юзер в тому ж методі пост:
 -використовуєм метод req.query
 -перевірка чи є юзер з таким емейлом метод users.some(user=>user.email===req.body.email) і запишем результат відпрацювання в змінну
 -далі іфом перевірим тру чи фолс і якщо тру то перекинем на сторінку помилки
 -якщо фолс то запушим юзера в загальний масив
 -переведем на сторінку юзерів де відмалюється вес масив

 17. для фільтрації по квері параметрам:
 -в методі де відмальовуєм всіх юзерів деструктуризуєм з реквесту квері - {query}
 -перевірим чи є у наших квері довжина - if (Object.keys(query).length)
 -якщо нема то зупиним код ретурном
 -якщо є то зробим копію нашого основного масиву юзерів - let user = [...users]
 -далі іфом перевірим чи потрібний квері параметр існує
 -якщо існує то відфільтруєм у цей ж масив наш збіг -  user = user.filter(user => user.city === query.city)
 -так само фільтруєм інші квері параметри
 -при закінченні перевірок рендерим сторінку з юзерами передавши наш відфільтрований масив
 res.render('users', {users: user})
 -зупиняєм код.

 18. перехід на не існуючий шлях:
 - в самому кінці наших методів з шляхами викликаєм метод app.use але
 шлях зовсім не передаєм.
 -стандартний колбек
 -в респонсі рендерим хбс вюшку notFound з необхідним контекстом
 -метод app.use не дивиться на шлях а відпрацює зразу тому його ставим в сам низ





